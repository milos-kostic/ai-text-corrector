================================================================================
SOURCE CODE COLLECTION
Generated: 2025-11-25 14:56:44.362009
================================================================================


============================================================
FILE: app.py
============================================================

"""
app.py - AI Text Corrector API
================================
Simple, clean, production-ready.
Focus: Make money, not perfect code.
"""

from flask import Flask, request, jsonify
import logging
from simple_error_handler import setup_simple_logging, handle_errors, validate_request

from correctors.spelling_corrector import SpellingCorrector
from correctors.grammar_corrector import GrammarCorrector

app = Flask(__name__)

# Setup logging
setup_simple_logging()
logger = logging.getLogger(__name__)

# Initialize correctors
try:
    spelling_corrector = SpellingCorrector()
    grammar_corrector = GrammarCorrector()
    logger.info("‚úì Correctors loaded")
except Exception as e:
    logger.critical(f"‚úó Failed to load correctors: {e}")
    spelling_corrector = None
    grammar_corrector = None


@app.route('/')
def home():
    return jsonify({
        'service': 'AI Text Corrector API',
        'version': '1.4.0',
        'endpoints': ['/correct', '/correct/spelling', '/correct/grammar', '/correct/batch', '/health']
    })


@app.route('/correct', methods=['POST'])
@handle_errors
def correct_all():
    """Main endpoint - full correction"""

    text = validate_request()

    if not text:
        return jsonify({"original": "", "corrected": "", "changed": False})

    corrected = grammar_corrector.correct(text)

    return jsonify({
        "original": text,
        "corrected": corrected,
        "changed": corrected != text
    })


@app.route('/correct/spelling', methods=['POST'])
@handle_errors
def correct_spelling():
    """Spelling only"""

    text = validate_request()

    if not text:
        return jsonify({"original": "", "corrected": "", "changed": False})

    corrected = spelling_corrector.correct(text)

    return jsonify({
        "original": text,
        "corrected": corrected,
        "changed": corrected != text
    })


@app.route('/correct/grammar', methods=['POST'])
@handle_errors
def correct_grammar():
    """Grammar only"""

    text = validate_request()

    if not text:
        return jsonify({"original": "", "corrected": "", "changed": False})

    corrected = grammar_corrector.correct(text)

    return jsonify({
        "original": text,
        "corrected": corrected,
        "changed": corrected != text
    })


@app.route('/correct/batch', methods=['POST'])
@handle_errors
def correct_batch():
    """Batch processing"""

    if not request.is_json:
        raise ValueError("Send JSON")

    data = request.get_json()
    if not data or 'texts' not in data:
        raise ValueError("Missing 'texts' array")

    texts = data['texts']

    if not isinstance(texts, list):
        raise ValueError("'texts' must be array")

    if len(texts) > 100:
        raise ValueError("Max 100 texts per batch")

    results = []
    for text in texts:
        if not isinstance(text, str):
            results.append({"original": text, "corrected": "", "error": "Not a string"})
            continue

        text = text.strip()
        try:
            corrected = grammar_corrector.correct(text)
            results.append({
                "original": text,
                "corrected": corrected,
                "changed": corrected != text
            })
        except Exception as e:
            results.append({"original": text, "corrected": "", "error": str(e)})

    return jsonify({"results": results, "batch_size": len(texts)})


@app.route('/health')
def health():
    """Health check"""
    ok = spelling_corrector is not None and grammar_corrector is not None
    return jsonify({
        'status': 'healthy' if ok else 'unhealthy',
        'correctors': ok
    }), 200 if ok else 503


# Custom error handlers for common HTTP errors
@app.errorhandler(400)
def bad_request(e):
    return jsonify({"error": "Bad request", "status": "error"}), 400


@app.errorhandler(404)
def not_found(e):
    return jsonify({"error": "Not found", "status": "error"}), 404


@app.errorhandler(405)
def method_not_allowed(e):
    return jsonify({"error": "Method not allowed", "status": "error"}), 405


@app.errorhandler(500)
def internal_error(e):
    logger.error(f"500 error: {str(e)}")
    return jsonify({"error": "Internal error", "status": "error"}), 500


if __name__ == '__main__':
    logger.info("=" * 50)
    logger.info("üöÄ Starting API server")
    logger.info("=" * 50)
    app.run(host='0.0.0.0', port=5000)


============================================================
FILE: correctors\base_corrector.py
============================================================

import re
import logging
from typing import Dict, List, Tuple
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class CorrectionLevel(Enum):
    MINIMAL = "minimal"
    STANDARD = "standard"
    AGGRESSIVE = "aggressive"


@dataclass
class CorrectionResult:
    original: str
    corrected: str
    changes_made: bool
    correction_level: CorrectionLevel
    processing_time_ms: float
    corrections_applied: List[str] = None
    confidence_score: float = 1.0

    def __post_init__(self):
        if self.corrections_applied is None:
            self.corrections_applied = []


# ============================================================
# SPECIAL FORMAT PRESERVATION
# ============================================================

class TextPreservation:
    SPECIAL_PATTERNS = {
        'email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
        'url': r'https?://[^\s<>{}|\\^~\[\]`]+',
        'hashtag': r'#\w+',
        'mention': r'@\w+',
    }

    COMPILED_PATTERNS = {name: re.compile(pattern) for name, pattern in SPECIAL_PATTERNS.items()}

    @classmethod
    def preserve_special_formats(cls, text: str) -> Tuple[str, Dict[str, str]]:
        preserved = {}
        preserved_text = text

        for format_type, pattern in cls.COMPILED_PATTERNS.items():
            matches = pattern.findall(preserved_text)
            for idx, match in enumerate(matches):
                placeholder = f"__{format_type.upper()}_{idx}__"
                preserved[placeholder] = match
                preserved_text = preserved_text.replace(match, placeholder, 1)

        return preserved_text, preserved

    @classmethod
    def restore_special_formats(cls, text: str, preserved: Dict[str, str]) -> str:
        for placeholder, original in preserved.items():
            text = text.replace(placeholder, original)
        return text


# ================================
# NORMALIZATION
# ================================

class TextNormalizer:
    WHITESPACE_PATTERN = re.compile(r'\s+')
    ZERO_WIDTH_PATTERN = re.compile(r'[\u200B-\u200D\uFEFF]')

    @staticmethod
    def normalize_whitespace(text: str) -> str:
        text = TextNormalizer.WHITESPACE_PATTERN.sub(' ', text)
        return text.strip()

    @staticmethod
    def remove_zero_width(text: str) -> str:
        return TextNormalizer.ZERO_WIDTH_PATTERN.sub('', text)

    @staticmethod
    def normalize_quotes(text: str) -> str:
        replacements = [
            ('‚Äò', "'"), ('‚Äô', "'"), ('‚Äö', "'"), ('‚Äõ', "'"),
            ('"', '"'), ('"', '"'), ('"', '"'), ('"', '"'),
            ('¬¥', "'"), ('`', "'"), (' ª', "'"), (' º', "'"),
            ('√¢‚Ç¨Àú', "'"), ('√¢‚Ç¨‚Ñ¢', "'"), ('√¢‚Ç¨≈ì', '"'), ('√¢‚Ç¨', '"'),
            ('√É¬¢√¢‚Äö¬¨√ã≈ì', "'"), ('√É¬¢√¢‚Äö¬¨√¢‚Äû¬¢', "'"), ('√É¬¢√¢‚Äö¬¨√Ö"', '"'),
        ]

        for wrong, correct in replacements:
            if wrong in text:
                text = text.replace(wrong, correct)

        return text

    @staticmethod
    def fix_all_caps(text: str) -> str:
        if text.isupper():
            t = text.lower()
            if len(t) == 0:
                return t
            return t[0].upper() + t[1:]
        return text

    @staticmethod
    def mild_random_case_fix(text: str) -> str:
        words = text.split()
        out = []
        for w in words:
            if any(c.islower() for c in w) and any(c.isupper() for c in w):
                out.append(w.lower())
            else:
                out.append(w)
        return " ".join(out)


# ================================
# SMART CAPITALIZATION (BALANCED)
# ================================

class SentenceCapitalizer:
    ALPHA_PATTERN = re.compile(r'[A-Za-z–ê-–Ø–∞-—è]')
    STANDALONE_I_PATTERN = re.compile(r'\bi\b')

    @staticmethod
    def smart_capitalize(text: str) -> str:
        """
        BALANCED VERSION: Good for both basic and edge cases
        """
        if not text:
            return text

        # First, capitalize standalone 'i'
        text = SentenceCapitalizer.STANDALONE_I_PATTERN.sub('I', text)

        # Capitalize first letter
        text = SentenceCapitalizer.capitalize_first_letter(text)

        try:
            # üî• BALANCED APPROACH: Handle ellipsis properly
            def capitalize_after_sentence(match):
                before_text = text[:match.start()]
                punctuation = match.group(1)
                space = match.group(2)
                next_char = match.group(3)

                # üî• CRITICAL: Don't capitalize after ellipsis
                if punctuation == '.':
                    # Check if this is part of ellipsis
                    recent_chars = before_text[-5:] if len(before_text) > 5 else before_text
                    if re.search(r'\.{2,}$', recent_chars):  # Ellipsis detected
                        return match.group(0)  # Don't capitalize

                # Capitalize after normal sentence endings
                return punctuation + space + next_char.upper()

            # Apply balanced capitalization
            pattern = r'([.!?])(\s+)([a-z])'
            text = re.sub(pattern, capitalize_after_sentence, text)

        except Exception as e:
            logger.warning(f"Capitalization error: {e}")

        return text

    @staticmethod
    def capitalize_first_letter(text: str) -> str:
        """Capitalize first letter of text while preserving leading whitespace"""
        if not text:
            return text

        stripped = text.lstrip()
        if not stripped:
            return text

        leading_ws = text[:len(text) - len(stripped)]

        # Skip if this is a preserved placeholder
        if stripped.startswith('__'):
            return text

        # Find first alphabetical character
        m = SentenceCapitalizer.ALPHA_PATTERN.search(stripped)
        if m:
            idx = m.start()
            new_stripped = stripped[:idx] + stripped[idx].upper() + stripped[idx + 1:]
            return leading_ws + new_stripped

        return text

    @staticmethod
    def capitalize_standalone_i(text: str) -> str:
        return SentenceCapitalizer.STANDALONE_I_PATTERN.sub('I', text)


# ================================
# PUNCTUATION (BALANCED)
# ================================

class PunctuationHandler:
    # üî• BALANCED: Preserve ellipsis but fix basic cases
    MULTIPLE_DOTS = re.compile(r'\.{4,}')  # Collapse 4+ dots to 3 (preserve ...)
    MULTIPLE_EXCLAMATION = re.compile(r'!{2,}')
    MULTIPLE_QUESTION = re.compile(r'\?{2,}')
    MISSING_SPACE_AFTER = re.compile(r'([,!;:])(?=[^\s])')
    APOSTROPHE_FIX = re.compile(r"(?<!\w)'(?!\w|s\b)")

    # üî• NEW: Fix double periods but preserve ellipsis
    DOUBLE_PERIODS = re.compile(r'\.{2,3}(?!\.)')  # 2-3 dots not followed by another dot

    @staticmethod
    def add_proper_spacing(text: str) -> str:
        """
        BALANCED VERSION: Good for both test suites
        """
        try:
            # üî• CRITICAL: First preserve ellipsis, then fix basic periods
            # Collapse 4+ dots to 3 (preserve ellipsis)
            text = PunctuationHandler.MULTIPLE_DOTS.sub('...', text)

            # üî• FIX for test_basic: Collapse 2-3 dots to single period (but not if it's ellipsis)
            # This handles "Hello.. world" ‚Üí "Hello. world" but preserves "hello... world"
            def fix_double_periods(match):
                dots = match.group(0)
                # If it's exactly 3 dots, keep as ellipsis
                if dots == '...':
                    return '...'
                # If it's 2 dots, collapse to 1
                return '.'

            text = PunctuationHandler.DOUBLE_PERIODS.sub(fix_double_periods, text)

            # Collapse repeated punctuation
            text = PunctuationHandler.MULTIPLE_EXCLAMATION.sub('!', text)
            text = PunctuationHandler.MULTIPLE_QUESTION.sub('?', text)

            # Only add space after commas/semicolons/colons if missing
            text = PunctuationHandler.MISSING_SPACE_AFTER.sub(r'\1 ', text)

            return text
        except Exception as e:
            logger.warning(f"Punctuation spacing error: {e}")
            return text

    @staticmethod
    def fix_apostrophes(text: str) -> str:
        try:
            return PunctuationHandler.APOSTROPHE_FIX.sub("'", text)
        except:
            return text


# ================================
# SECURITY CHECK
# ================================

class SecuritySanitizer:
    SECURITY_PATTERNS = [
        re.compile(r'<script.*?>', re.IGNORECASE),
        re.compile(r'javascript:', re.IGNORECASE),
        re.compile(r'vbscript:', re.IGNORECASE),
        re.compile(r'\b(SELECT|INSERT|UPDATE|DELETE|DROP|UNION)\b', re.IGNORECASE),
        re.compile(r'rm\s+-rf', re.IGNORECASE),
        re.compile(r'wget\s+http', re.IGNORECASE),
        re.compile(r'curl\s+http', re.IGNORECASE),
    ]

    @staticmethod
    def contains_suspicious_patterns(text: str) -> bool:
        return any(pattern.search(text) for pattern in SecuritySanitizer.SECURITY_PATTERNS)


# ================================
# BASE CORRECTOR (BALANCED FINAL)
# ================================

class BaseCorrector(ABC):

    def __init__(self, correction_level=CorrectionLevel.STANDARD):
        self.correction_level = correction_level
        self.setup_dictionaries()

        self.normalizer = TextNormalizer()
        self.preservation_handler = TextPreservation()
        self.punctuation_handler = PunctuationHandler()
        self.security_sanitizer = SecuritySanitizer()
        self.capitalizer = SentenceCapitalizer()

    @abstractmethod
    def setup_dictionaries(self):
        pass

    @abstractmethod
    def core_correction_logic(self, text: str) -> Tuple[str, List[str]]:
        pass

    def correct(self, text: str) -> str:
        try:
            if not text or not isinstance(text, str):
                return text

            if text.strip() == "":
                return ""

            if self.security_sanitizer.contains_suspicious_patterns(text):
                return text

            # Early return for very short texts
            if len(text) < 3:
                return text.capitalize() if text else text

            # Apply normalizations in order
            t = self.normalizer.normalize_quotes(text)
            t = self.normalizer.normalize_whitespace(t)
            t = self.normalizer.remove_zero_width(t)
            t = self.normalizer.fix_all_caps(t)
            t = self.normalizer.mild_random_case_fix(t)

            # Capitalize standalone 'i' early
            t = self.capitalizer.capitalize_standalone_i(t)

            # Preserve special formats
            t, preserved = self.preservation_handler.preserve_special_formats(t)

            # Core correction logic
            t, _ = self.core_correction_logic(t)

            # Punctuation fixes
            t = self.punctuation_handler.add_proper_spacing(t)
            t = self.punctuation_handler.fix_apostrophes(t)

            # Smart capitalization
            t = self.capitalizer.smart_capitalize(t)

            # Restore preserved formats
            t = self.preservation_handler.restore_special_formats(t, preserved)

            return t

        except Exception as e:
            logger.error(f"Error in corrector: {e}")
            return text.capitalize() if text else text


============================================================
FILE: correctors\contextual_corrector.py
============================================================

"""
correctors/contextual_corrector.py

Contextual spelling correction for commonly confused words.
Handles: their/there/they're, your/you're, its/it's, etc.
"""

import re
from typing import List, Tuple


class ContextualCorrector:
    """
    Fixes contextually confused homophones based on grammar patterns.
    """

    def __init__(self):
        self.setup_patterns()

    def setup_patterns(self):
        """Define patterns for contextual corrections"""

        # Words that typically follow "you're" (verbs, adjectives, adverbs)
        self.youre_indicators = [
            'going', 'welcome', 'right', 'wrong', 'awesome', 'amazing',
            'beautiful', 'crazy', 'doing', 'getting', 'being', 'looking',
            'feeling', 'thinking', 'saying', 'making', 'having', 'coming',
            'leaving', 'running', 'walking', 'talking', 'working', 'playing',
            'here', 'there', 'sure', 'not', 'so', 'very', 'really', 'quite',
            'about', 'probably', 'definitely', 'certainly', 'likely'
        ]

        # Words that typically follow "your" (nouns, possessive contexts)
        self.your_indicators = [
            'car', 'house', 'book', 'phone', 'computer', 'dog', 'cat',
            'friend', 'family', 'mother', 'father', 'brother', 'sister',
            'name', 'email', 'address', 'time', 'money', 'job', 'life',
            'idea', 'problem', 'question', 'answer', 'work', 'home',
            'room', 'bed', 'desk', 'chair', 'table', 'own', 'turn',
            'head', 'eyes', 'hand', 'body', 'mind', 'heart', 'soul'
        ]

        # Words that follow "they're" (verbs, adjectives, adverbs)
        self.theyre_indicators = [
            'going', 'coming', 'here', 'there', 'not', 'so', 'very',
            'happy', 'sad', 'angry', 'excited', 'ready', 'doing',
            'making', 'having', 'being', 'getting', 'saying', 'thinking',
            'working', 'playing', 'running', 'walking', 'talking',
            'right', 'wrong', 'sure', 'fine', 'okay', 'great', 'good',
            'bad', 'amazing', 'awesome', 'beautiful', 'crazy'
        ]

        # Words that follow "their" (nouns)
        self.their_indicators = [
            'car', 'house', 'dog', 'cat', 'friend', 'family', 'children',
            'parents', 'room', 'home', 'work', 'job', 'life', 'time',
            'money', 'idea', 'problem', 'question', 'answer', 'name',
            'phone', 'computer', 'book', 'own', 'turn', 'way', 'place',
            'head', 'eyes', 'hands', 'body', 'minds', 'hearts'
        ]

        # Compile regex patterns for efficiency
        self._compile_patterns()

    def _compile_patterns(self):
        """Compile regex patterns for better performance"""

        # YOUR/YOU'RE patterns
        self.your_pattern = re.compile(
            r'\b(your|you\'?re)\s+(\w+)',
            re.IGNORECASE
        )

        # THEIR/THERE/THEY'RE patterns
        self.their_pattern = re.compile(
            r'\b(their|there|they\'?re)\s+(\w+)',
            re.IGNORECASE
        )

        # ITS/IT'S patterns
        self.its_pattern = re.compile(
            r'\b(its|it\'?s)\s+(\w+)',
            re.IGNORECASE
        )

    def correct_your_youre(self, text: str) -> str:
        """
        Fix your/you're confusion based on following word.

        Rules:
        - "your" + verb/adjective/adverb ‚Üí "you're"
        - "you're" + noun ‚Üí "your"
        - Special cases: "your welcome" ‚Üí "you're welcome"
        """

        def replacement(match):
            current_word = match.group(1).lower()
            next_word = match.group(2).lower()

            # Preserve original capitalization
            was_capitalized = match.group(1)[0].isupper()

            # Check if next word indicates "you're" usage
            if next_word in self.youre_indicators:
                correct = "you're"
            # Check if next word indicates "your" usage
            elif next_word in self.your_indicators:
                correct = "your"
            # Default: keep as is if unsure
            else:
                # If current is "your" and next word ends in 'ing' ‚Üí probably "you're going"
                if current_word in ['your', 'youre'] and next_word.endswith('ing'):
                    correct = "you're"
                # If next word is a noun (ends in common noun suffixes)
                elif next_word.endswith(('tion', 'ness', 'ment', 'ity', 'er', 'or', 'ist')):
                    correct = "your"
                else:
                    return match.group(0)  # Keep original

            # Apply original capitalization
            if was_capitalized:
                correct = correct.capitalize()

            return f"{correct} {match.group(2)}"

        return self.your_pattern.sub(replacement, text)

    def correct_their_there_theyre(self, text: str) -> str:
        """
        Fix their/there/they're confusion.

        Rules:
        - "their" + noun (possessive)
        - "there" + is/are/was/were (existential)
        - "there" + location prepositions (by, in, at, on)
        - "they're" + verb/adjective/adverb (contraction of "they are")
        """

        def replacement(match):
            current_word = match.group(1).lower()
            next_word = match.group(2).lower()

            was_capitalized = match.group(1)[0].isupper()

            # "there is/are/was/were" OR location words ‚Üí always "there"
            if next_word in ['is', 'are', 'was', 'were', 'will', 'would', 'should', 'by', 'in', 'at', 'on']:
                correct = "there"
            # Check for "they're" indicators (verbs, adjectives)
            elif next_word in self.theyre_indicators or next_word.endswith('ing'):
                correct = "they're"
            # Check for "their" indicators (nouns)
            elif next_word in self.their_indicators:
                correct = "their"
            # Default heuristic
            else:
                # If next word is likely a verb ‚Üí "they're"
                if next_word.endswith(('ing', 'ed')) or next_word in ['happy', 'sad', 'ready', 'here', 'not']:
                    correct = "they're"
                # Likely a noun ‚Üí "their"
                else:
                    correct = "their"

            if was_capitalized:
                correct = correct.capitalize()

            return f"{correct} {match.group(2)}"

        return self.their_pattern.sub(replacement, text)

    def correct_its_its(self, text: str) -> str:
        """
        Fix its/it's confusion.

        Rules:
        - "it's" = "it is" or "it has" (contraction)
        - "its" = possessive
        """

        def replacement(match):
            current_word = match.group(1).lower()
            next_word = match.group(2).lower()

            was_capitalized = match.group(1)[0].isupper()

            # "it's" before verbs/adjectives (it is/has)
            if next_word in ['a', 'the', 'not', 'been', 'going', 'time', 'okay', 'fine', 'good', 'bad']:
                correct = "it's"
            # "its" before nouns (possessive)
            else:
                correct = "its"

            if was_capitalized:
                correct = correct.capitalize()

            return f"{correct} {match.group(2)}"

        return self.its_pattern.sub(replacement, text)

    def correct(self, text: str) -> str:
        """
        Apply all contextual corrections to text.
        Order matters: process from most to least ambiguous.
        """
        if not text or not isinstance(text, str):
            return text

        # Apply corrections in sequence
        text = self.correct_your_youre(text)
        text = self.correct_their_there_theyre(text)
        text = self.correct_its_its(text)

        return text


============================================================
FILE: correctors\grammar_corrector.py
============================================================

"""
correctors/grammar_corrector.py

Grammar correction with contextual spelling support.
"""

from .base_corrector import BaseCorrector
from .spelling_corrector import SpellingCorrector
from .contextual_corrector import ContextualCorrector
import re
from typing import Tuple, List


class GrammarCorrector(BaseCorrector):

    def setup_dictionaries(self):
        try:
            self.spelling_corrector = SpellingCorrector()
        except Exception:
            self.spelling_corrector = None

        # Initialize contextual corrector
        try:
            self.contextual_corrector = ContextualCorrector()
        except Exception:
            self.contextual_corrector = None

        # ========================================
        # CONTRACTIONS - EXPANDED
        # ========================================
        self.contractions = {
            'dont': "don't",
            'doesnt': "doesn't",
            'didnt': "didn't",
            'wont': "won't",
            'cant': "can't",
            'couldnt': "couldn't",
            'shouldnt': "shouldn't",
            'wouldnt': "wouldn't",
            'isnt': "isn't",
            'arent': "aren't",
            'wasnt': "wasn't",
            'werent': "weren't",
            'hasnt': "hasn't",
            'havent': "haven't",
            'hadnt': "hadn't",
            'im': "I'm",
            'youre': "you're",
            'hes': "he's",
            'shes': "she's",
            'its': "it's",
            'were': "we're",  # OVO JE PROBLEM - treba da se izbegne
            'theyre': "they're",
            'ive': "I've",
            'youve': "you've",
            'weve': "we've",
            'theyve': "they've",
            'ill': "I'll",
            'youll': "you'll",
            'hell': "he'll",
            'shell': "she'll",
            'well': "we'll",  # OVO JE PROBLEM - treba da se izbegne
            'theyll': "they'll",
            'id': "I'd",
        }

        # ========================================
        # IRREGULAR VERBS - EXPANDED
        # ========================================
        self.irregular_verbs = {
            'goed': 'went',
            'runned': 'ran',
            'eated': 'ate',
            'drinked': 'drank',
            'buyed': 'bought',
            'thinked': 'thought',
            'comed': 'came',
            'sayed': 'said',
            'maked': 'made',
            'taked': 'took',
            'gived': 'gave',
            'sended': 'sent',
            'finded': 'found',
            'knowed': 'knew',
            'writed': 'wrote',

            # Perfect tense
            'has ate': 'has eaten',
            'have ate': 'have eaten',
            'has went': 'has gone',
            'have went': 'have gone',
            'has ran': 'has run',
            'have ran': 'have run',
            'has came': 'has come',
            'have came': 'have come',
            'has wrote': 'has written',
            'have wrote': 'have written',

            # Negative past
            "didn't went": "didn't go",
            "didn't ate": "didn't eat",
            "didn't drank": "didn't drink",
            "didn't came": "didn't come",
            "didn't ran": "didn't run",
            "didn't saw": "didn't see",
            "didn't wrote": "didn't write",

            # Was/were constructions
            'was went': 'went',
            'was ate': 'ate',
            'was came': 'came',
            'were went': 'went',
        }

        # ========================================
        # VERB AGREEMENT - GREATLY EXPANDED
        # ========================================
        self.verb_agreements = {
            # Have/Has
            'he have': 'he has',
            'she have': 'she has',
            'it have': 'it has',
            'they has': 'they have',
            'we has': 'we have',
            'you has': 'you have',
            'i has': 'i have',

            # Do/Does
            'he do': 'he does',
            'she do': 'she does',
            'it do': 'it does',
            'they does': 'they do',
            'we does': 'we do',
            'you does': 'you do',

            # Go/Goes
            'he go': 'he goes',
            'she go': 'she goes',
            'it go': 'it goes',

            # Is/Are/Am
            'he are': 'he is',
            'she are': 'she is',
            'it are': 'it is',
            'they is': 'they are',
            'we is': 'we are',
            'you is': 'you are',
            'i is': 'i am',

            # Was/Were
            'i were': 'i was',  # OVO JE KLJUƒåNO - popravlja "i were" ‚Üí "I was"
            'he were': 'he was',
            'she were': 'she was',
            'it were': 'it was',
            'we was': 'we were',
            'they was': 'they were',
            'you was': 'you were',

            # Don't/Doesn't
            'she dont': "she doesn't",
            'he dont': "he doesn't",
            'it dont': "it doesn't",
            "he don't": "he doesn't",
            "she don't": "she doesn't",
            "it don't": "it doesn't",
            "we doesn't": "we don't",
            "they doesn't": "they don't",
            "i doesn't": "i don't",
            "you doesn't": "you don't",

            # NEW - Demonstratives (this/that/these/those) - CRITICAL FIX
            'this are': 'this is',
            'that are': 'that is',
            'this were': 'this was',
            'that were': 'that was',
            'these is': 'these are',
            'those is': 'those are',
            'these was': 'these were',
            'those was': 'those were',
        }

        # ========================================
        # COMPOUND SUBJECT + VERB AGREEMENT
        # ========================================
        self.compound_subject_fixes = {
            'he and i was': 'he and i were',
            'she and i was': 'she and i were',
            'you and i was': 'you and i were',
            'they and i was': 'they and i were',
            'we and i was': 'we and i were',
            'he and she was': 'he and she were',
            'him and i was': 'he and i were',
            'her and i was': 'she and i were',

            # üî• FIX #2: "I and I" patterns (after pronoun correction "me and i" ‚Üí "i and i")
            'i and i was': 'i and i were',
            'i and i is': 'i and i are',

            # üî• FIX #2: More compound patterns with "was"
            'me and you was': 'you and i were',
            'me and he was': 'he and i were',
            'me and she was': 'she and i were',
            'me and him was': 'he and i were',
            'me and her was': 'she and i were',
        }

        # ========================================
        # PRONOUN SUBJECT/OBJECT
        # ========================================
        self.pronoun_corrections = {
            'me am': 'i am',
            'me is': 'i am',
            'me was': 'i was',
            'me were': 'i was',
            'me have': 'i have',
            'me do': 'i do',
            'me go': 'i go',
            'me like': 'i like',
            'me want': 'i want',
            'me need': 'i need',
            'me think': 'i think',
            'me know': 'i know',
            'me understand': 'i understand',

            # üî• FIX #2: "me and [pronoun]" patterns
            'me and i': 'i and i',
            'me and you': 'you and i',
            'me and he': 'he and i',
            'me and she': 'she and i',
            'me and him': 'he and i',
            'me and her': 'she and i',
            'me and they': 'they and i',
            'me and we': 'we and i',

            # üî• FIX #2: Reverse order
            'i and me': 'i and i',
            'you and me': 'you and i',
            'he and me': 'he and i',
            'she and me': 'she and i',
            'him and me': 'he and i',
            'her and me': 'she and i',
            'they and me': 'they and i',
            'we and me': 'we and i',
        }

        # ========================================
        # ARTICLES - EXPANDED
        # ========================================
        self.article_corrections = {
            'a apple': 'an apple',
            'a orange': 'an orange',
            'a umbrella': 'an umbrella',
            'a hour': 'an hour',
            'a honest': 'an honest',
            'a interesting': 'an interesting',
            'a elephant': 'an elephant',
            'a eagle': 'an eagle',
            'a onion': 'an onion',
            'a octopus': 'an octopus',

            'an book': 'a book',
            'an house': 'a house',
            'an car': 'a car',
            'an dog': 'a dog',
            'an table': 'a table',
            'an university': 'a university',
            'an user': 'a user',
            'an european': 'a european',
            'an one': 'a one',
        }

        # ========================================
        # WORD ORDER - EXPANDED
        # ========================================
        self.word_order_rules = {
            'i tomorrow will': 'i will tomorrow',
            'always he': 'he always',
            'never i': 'i never',
            'often she': 'she often',
            'sometimes they': 'they sometimes',
            'always we': 'we always',
            'usually he': 'he usually',
            'yesterday i go': 'yesterday i went',  # üî• FIX #3: Keep "yesterday" at start

            # Question word order fixes
            'why she dont': 'why doesn\'t she',
            'why she doesn\'t': 'why doesn\'t she',
            'why he dont': 'why doesn\'t he',
            'why he doesn\'t': 'why doesn\'t he',
            'why they doesnt': 'why don\'t they',
            'why they doesn\'t': 'why don\'t they',
        }

        # ========================================
        # PREPOSITIONS - EXPANDED
        # ========================================
        self.preposition_rules = {
            'arrived to': 'arrived at',
            'listen me': 'listen to me',
            'wait to': 'wait for',
            'discuss about': 'discuss',
            'married with': 'married to',
            'different than': 'different from',
            'depend of': 'depend on',
        }

        # ========================================
        # COMMON PHRASES - EXPANDED
        # NOTE: Removed "their"->"there" and "your"->"you're"
        # These are now handled by contextual_corrector
        # ========================================
        self.common_phrases = {
            "it's me": "it's I",
            "me and him": "he and I",
            "me and her": "she and I",
            "him and me": "he and I",
            "her and me": "she and I",
            "me and you": "you and I",

            "more better": "better",
            "most easiest": "easiest",
            "more faster": "faster",
            "most biggest": "biggest",

            "could of": "could have",
            "should of": "should have",
            "would of": "would have",
            "must of": "must have",
            "might of": "might have",

            "alot": "a lot",
            "incase": "in case",
            "atleast": "at least",
            "aswell": "as well",
        }

        # ========================================
        # NEW - Common adjectives that need article before noun
        # ========================================
        self.common_adjectives = {
            'bad', 'good', 'great', 'big', 'small', 'new', 'old', 'nice',
            'beautiful', 'ugly', 'happy', 'sad', 'fast', 'slow', 'hot', 'cold',
            'long', 'short', 'high', 'low', 'strong', 'weak', 'clean', 'dirty',
            'easy', 'hard', 'simple', 'complex', 'true', 'false', 'correct', 'wrong',
            'real', 'fake', 'rich', 'poor', 'young', 'wise', 'foolish', 'brave',
            'smart', 'stupid', 'funny', 'serious', 'important', 'dangerous', 'safe'
        }

        self._compile_combined_patterns()

    def _compile_combined_patterns(self):
        try:
            # Contractions pattern - IZBACUJEMO 'were' i 'well' iz kontrakcija
            contractions_without_problems = {k: v for k, v in self.contractions.items()
                                           if k not in ['were', 'well']}
            self.contractions_pattern = re.compile(
                r'\b(' + '|'.join(map(re.escape, contractions_without_problems.keys())) + r')\b',
                re.IGNORECASE
            )

            # üî• FIX #2: Recompile pronoun pattern with new entries
            self.pronoun_pattern = re.compile(
                r'\b(' + '|'.join(map(re.escape, self.pronoun_corrections.keys())) + r')\b',
                re.IGNORECASE
            )

            # üî• FIX #2: Recompile compound subject pattern with new entries
            self.compound_subject_pattern = re.compile(
                r'\b(' + '|'.join(map(re.escape, self.compound_subject_fixes.keys())) + r')\b',
                re.IGNORECASE
            )

            self.combined_verb_pattern = re.compile(
                r'\b(' + '|'.join(map(re.escape, self.verb_agreements.keys())) + r')\b',
                re.IGNORECASE
            )
            self.combined_irregular_pattern = re.compile(
                r'\b(' + '|'.join(map(re.escape, self.irregular_verbs.keys())) + r')\b',
                re.IGNORECASE
            )
            self.combined_word_order_pattern = re.compile(
                r'\b(' + '|'.join(map(re.escape, self.word_order_rules.keys())) + r')\b',
                re.IGNORECASE
            )
            self.combined_preposition_pattern = re.compile(
                r'\b(' + '|'.join(map(re.escape, self.preposition_rules.keys())) + r')\b',
                re.IGNORECASE
            )
        except Exception:
            pass

    def correct_contractions(self, text: str) -> str:
        """Fix missing apostrophes in contractions - POBOLJ≈†ANA VERZIJA"""

        def replacement(match):
            word = match.group().lower()

            # üî• FIX: Spreƒçava "were" ‚Üí "we're" gre≈°ku
            if word == 'were':
                return match.group()  # Vrati original "were"

            # üî• NOVI FIX: Spreƒçava "well" ‚Üí "we'll" gre≈°ku
            if word == 'well':
                return match.group()  # Vrati original "well"

            correct = self.contractions.get(word, word)

            # üî• POBOLJ≈†ANJE: Uvek kapitalizuj "I" u kontrakcijama
            if correct.lower().startswith("i"):
                correct = correct.replace('i', 'I')

                # Poseban sluƒçaj za kontrakcije u sredini reƒçenice
                if match.group()[0].islower() and not match.group()[0].isupper():
                    # Ovo je "i'm" u sredini - kapitalizuj samo "I"
                    correct = 'I' + correct[1:]

            # Preserve original casing for first character
            elif match.group()[0].isupper():
                correct = correct.capitalize()

            return correct

        return self.contractions_pattern.sub(replacement, text)

    def prevent_well_correction(self, text: str) -> str:
        """
        Spreƒçava korekciju 'well' ‚Üí 'we'll' koja je pogre≈°na.
        """
        # Koristimo regex da zamenimo 'We'll' nazad u 'Well' kada je na poƒçetku reƒçenice
        text = re.sub(r'^We\'ll\b', 'Well', text)
        text = re.sub(r'\. We\'ll\b', '. Well', text)
        text = re.sub(r'\! We\'ll\b', '! Well', text)
        text = re.sub(r'\? We\'ll\b', '? Well', text)
        text = re.sub(r'\, We\'ll\b', ', Well', text)
        return text

    def fix_overcorrection_articles(self, text: str) -> str:
        """
        Popravlja preterano dodavanje ƒçlanova ispred pridjeva.
        """
        # Uklanja 'a/an' ispred pridjeva koji ne trebaju ƒçlan
        overcorrections = {
            'a young': 'young',
            'an young': 'young',
            'a old': 'old',
            'an old': 'old',
            'a big': 'big',
            'an big': 'big',
            'a small': 'small',
            'an small': 'small',
            'a rich': 'rich',
            'an rich': 'rich',
            'a poor': 'poor',
            'an poor': 'poor',
        }

        for wrong, correct in overcorrections.items():
            text = re.sub(r'\b' + re.escape(wrong) + r'\b', correct, text, flags=re.IGNORECASE)

        return text

    def correct_pronouns(self, text: str) -> str:
        """Fix subject pronoun errors like 'me am' -> 'i am' and 'me and i' -> 'i and i'"""

        def replacement(match):
            phrase = match.group().lower()
            correct = self.pronoun_corrections.get(phrase, phrase)

            # Always capitalize I
            if correct.startswith('i '):
                correct = 'I' + correct[1:]

            # Handle "I and I" pattern
            if 'i and i' in correct:
                correct = correct.replace('i and i', 'I and I')

            return correct

        return self.pronoun_pattern.sub(replacement, text)

    def correct_common_phrases(self, text: str) -> str:
        for wrong, correct in self.common_phrases.items():
            text = re.sub(r'\b' + re.escape(wrong) + r'\b', correct, text, flags=re.IGNORECASE)
        return text

    def correct_articles(self, text):
        words = text.split()
        out = []
        i = 0
        while i < len(words):
            if i < len(words) - 1:
                p = f"{words[i]} {words[i + 1]}".lower()
                if p in self.article_corrections:
                    out.extend(self.article_corrections[p].split())
                    i += 2
                    continue
            out.append(words[i])
            i += 1
        return ' '.join(out)

    def add_missing_articles(self, text: str) -> str:
        """
        Add missing indefinite article 'a/an' before adjective + noun patterns.
        POBOLJ≈†ANA VERZIJA: Spreƒçava dodavanje ƒçlana ispred pridjeva koji ne trebaju.
        """
        words = text.split()
        result = []
        i = 0

        while i < len(words):
            result.append(words[i])

            # Check if current word is a form of "be" verb
            if i < len(words) - 2 and words[i].lower() in ['is', 'was', 'are', 'were']:
                next_word = words[i + 1].lower()
                word_after = words[i + 2] if i + 2 < len(words) else None

                # Check if pattern is: be_verb + adjective + noun (without article)
                if next_word in self.common_adjectives and word_after:
                    # Don't add article if one already exists
                    if next_word not in ['a', 'an', 'the']:
                        # Check if word after adjective looks like a singular noun
                        # (simple heuristic: doesn't end in 's' for plural, not a verb form)
                        if not word_after.lower().endswith(('s', 'ing', 'ed', 'ly')):
                            # üî• POBOLJ≈†ANJE: Proveri da li je pridjev veƒá deo fraze
                            # Spreƒçava "was young" ‚Üí "was a young" gre≈°ku
                            common_adjective_phrases = {
                                'young', 'old', 'big', 'small', 'rich', 'poor'
                            }

                            if next_word not in common_adjective_phrases:
                                # Determine a vs an
                                if next_word[0] in 'aeiou':
                                    result.append('an')
                                else:
                                    result.append('a')

            i += 1

        return ' '.join(result)

    def apply_pattern_replacement(self, text, mapping, pattern):
        def repl(m):
            result = mapping.get(m.group().lower(), m.group())
            # Always capitalize standalone "I"
            result = re.sub(r'\bi\b', 'I', result)
            return result

        return pattern.sub(repl, text)

    def core_correction_logic(self, text: str) -> Tuple[str, List[str]]:
        corrected = text
        changes = []

        # 1. Spelling corrections
        if self.spelling_corrector:
            tmp = self.spelling_corrector.correct_spelling(corrected)
            if tmp != corrected:
                changes.append("spelling")
            corrected = tmp

        # 2. CONTEXTUAL SPELLING (before contractions!)
        if self.contextual_corrector:
            tmp = self.contextual_corrector.correct(corrected)
            if tmp != corrected:
                changes.append("contextual spelling")
            corrected = tmp

        # 3. Contractions (high priority) - POBOLJ≈†ANO
        tmp = self.correct_contractions(corrected)
        if tmp != corrected:
            changes.append("contractions")
        corrected = tmp

        # üî• NOVI FIX: Spreƒçava 'well' ‚Üí 'we'll' gre≈°ku
        tmp = self.prevent_well_correction(corrected)
        if tmp != corrected:
            changes.append("prevent well overcorrection")
        corrected = tmp

        # 4. üî• FIX #2: Pronoun corrections (BEFORE compound subjects)
        # This converts "me and i" -> "i and i" first
        tmp = self.correct_pronouns(corrected)
        if tmp != corrected:
            changes.append("pronouns")
        corrected = tmp

        # 5. Verb agreement
        tmp = self.apply_pattern_replacement(corrected, self.verb_agreements, self.combined_verb_pattern)
        if tmp != corrected:
            changes.append("verb agreement")
        corrected = tmp

        # 6. Irregular verbs
        tmp = self.apply_pattern_replacement(corrected, self.irregular_verbs, self.combined_irregular_pattern)
        if tmp != corrected:
            changes.append("irregular verb")
        corrected = tmp

        # 7. Common phrases (includes "me and him" ‚Üí "he and I")
        tmp = self.correct_common_phrases(corrected)
        if tmp != corrected:
            changes.append("common phrase")
        corrected = tmp

        # 8. üî• FIX #2: Compound subject + verb agreement (AFTER pronouns)
        # Now "i and i was" becomes "i and i were"
        tmp = self.apply_pattern_replacement(corrected, self.compound_subject_fixes, self.compound_subject_pattern)
        if tmp != corrected:
            changes.append("compound subject")
        corrected = tmp

        # 9. Articles (a/an corrections)
        tmp = self.correct_articles(corrected)
        if tmp != corrected:
            changes.append("article")
        corrected = tmp

        # 10. Add missing articles before adjective + noun
        tmp = self.add_missing_articles(corrected)
        if tmp != corrected:
            changes.append("missing article")
        corrected = tmp

        # üî• NOVI FIX: Popravlja preterano dodavanje ƒçlanova
        tmp = self.fix_overcorrection_articles(corrected)
        if tmp != corrected:
            changes.append("fix article overcorrection")
        corrected = tmp

        # 11. Word order (includes question fixes)
        tmp = self.apply_pattern_replacement(corrected, self.word_order_rules, self.combined_word_order_pattern)
        if tmp != corrected:
            changes.append("word order")
        corrected = tmp

        # 12. Prepositions
        tmp = self.apply_pattern_replacement(corrected, self.preposition_rules, self.combined_preposition_pattern)
        if tmp != corrected:
            changes.append("preposition")
        corrected = tmp

        return corrected, changes


============================================================
FILE: correctors\spelling_corrector.py
============================================================

"""
correctors/spelling_corrector.py

Basic spelling correction - does NOT handle contextual homophones.
Contextual words (their/your) are handled by contextual_corrector.py
"""

from .base_corrector import BaseCorrector
import re
from typing import Tuple, List


class SpellingCorrector(BaseCorrector):

    def setup_dictionaries(self):
        self.spelling_rules = {
            # Original rules
            "teh": "the",
            "adress": "address",
            "recieve": "receive",
            "occurence": "occurrence",
            "accomodate": "accommodate",
            "definately": "definitely",
            "seperate": "separate",
            "wich": "which",
            "becuase": "because",
            "alot": "a lot",
            "truely": "truly",
            "goverment": "government",
            "enviroment": "environment",
            "untill": "until",
            "wiches": "which",

            # NEW - Missing words that caused test failures
            "beleive": "believe",
            "beleve": "believe",
            "corect": "correct",
            "correkt": "correct",
            "terrble": "terrible",
            "terrable": "terrible",

            # BONUS - Additional common misspellings
            "awsome": "awesome",
            "freind": "friend",
            "occured": "occurred",
            "reccomend": "recommend",
            "necesary": "necessary",
            "tommorow": "tomorrow",
            "succesful": "successful",
            "embarass": "embarrass",
            "occassion": "occasion",
            "persue": "pursue",
            "arguement": "argument",
            "wierd": "weird",
            "foriegn": "foreign",
            "heighth": "height",
            "greatful": "grateful",
            "concious": "conscious",
            "posession": "possession",
            "cemetary": "cemetery",
            "millenium": "millennium",

            # REMOVED: "their": "there" - now handled by contextual_corrector
            # REMOVED: "your": "you're" - now handled by contextual_corrector
        }

        all_wrong = '|'.join(re.escape(w) for w in self.spelling_rules.keys())
        self.combined_spelling_pattern = re.compile(r'\b(' + all_wrong + r')\b', re.IGNORECASE)

    def correct_spelling(self, text: str) -> str:
        if not text or not isinstance(text, str):
            return text

        def replacement(match):
            word = match.group()
            wrong = word.lower()
            correct = self.spelling_rules.get(wrong, word)

            # Preserve original casing
            if word.isupper():
                return correct.upper()
            if word[0].isupper():
                return correct.capitalize()
            return correct

        try:
            return self.combined_spelling_pattern.sub(replacement, text)
        except Exception:
            return text

    def core_correction_logic(self, text: str) -> Tuple[str, List[str]]:
        corrected = self.correct_spelling(text)
        changes = []
        if corrected != text:
            changes.append("Applied spelling corrections")
        return corrected, changes


============================================================
FILE: correctors\__init__.py
============================================================

from .spelling_corrector import SpellingCorrector
from .grammar_corrector import GrammarCorrector

__all__ = ['SpellingCorrector', 'GrammarCorrector']



============================================================
FILE: auth.py
============================================================

from functools import wraps
from flask import request, jsonify
import os

# Minimalna verzija za MVP ‚Äî kljuƒçevi iz .env
VALID_API_KEYS = {
    "basic": os.getenv("API_KEY_BASIC", "basic_key_123"),
    "premium": os.getenv("API_KEY_PREMIUM", "premium_key_456"),
    "enterprise": os.getenv("API_KEY_ENTERPRISE", "enterprise_key_789"),
}

def require_api_key(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        api_key = request.headers.get("X-API-Key")

        if not api_key:
            return jsonify({"error": "API key required"}), 401

        plan = None
        for p, key in VALID_API_KEYS.items():
            if api_key == key:
                plan = p
                break

        if not plan:
            return jsonify({"error": "Invalid API key"}), 401

        request.current_plan = plan
        return f(*args, **kwargs)

    return wrapper


